diff --git a/config/__pycache__/maze2d.cpython-38.pyc b/config/__pycache__/maze2d.cpython-38.pyc
index 693d3f2..84d2ba9 100644
Binary files a/config/__pycache__/maze2d.cpython-38.pyc and b/config/__pycache__/maze2d.cpython-38.pyc differ
diff --git a/diffuser/__pycache__/__init__.cpython-38.pyc b/diffuser/__pycache__/__init__.cpython-38.pyc
index c820239..a5df34e 100644
Binary files a/diffuser/__pycache__/__init__.cpython-38.pyc and b/diffuser/__pycache__/__init__.cpython-38.pyc differ
diff --git a/diffuser/datasets/__pycache__/__init__.cpython-38.pyc b/diffuser/datasets/__pycache__/__init__.cpython-38.pyc
index ef17298..ccc82e2 100644
Binary files a/diffuser/datasets/__pycache__/__init__.cpython-38.pyc and b/diffuser/datasets/__pycache__/__init__.cpython-38.pyc differ
diff --git a/diffuser/datasets/__pycache__/buffer.cpython-38.pyc b/diffuser/datasets/__pycache__/buffer.cpython-38.pyc
index 29d1096..271b780 100644
Binary files a/diffuser/datasets/__pycache__/buffer.cpython-38.pyc and b/diffuser/datasets/__pycache__/buffer.cpython-38.pyc differ
diff --git a/diffuser/datasets/__pycache__/d4rl.cpython-38.pyc b/diffuser/datasets/__pycache__/d4rl.cpython-38.pyc
index cdb60d7..55ec862 100644
Binary files a/diffuser/datasets/__pycache__/d4rl.cpython-38.pyc and b/diffuser/datasets/__pycache__/d4rl.cpython-38.pyc differ
diff --git a/diffuser/datasets/__pycache__/normalization.cpython-38.pyc b/diffuser/datasets/__pycache__/normalization.cpython-38.pyc
index 8d5a9e5..e6671fc 100644
Binary files a/diffuser/datasets/__pycache__/normalization.cpython-38.pyc and b/diffuser/datasets/__pycache__/normalization.cpython-38.pyc differ
diff --git a/diffuser/datasets/__pycache__/preprocessing.cpython-38.pyc b/diffuser/datasets/__pycache__/preprocessing.cpython-38.pyc
index ae688c3..e9037c3 100644
Binary files a/diffuser/datasets/__pycache__/preprocessing.cpython-38.pyc and b/diffuser/datasets/__pycache__/preprocessing.cpython-38.pyc differ
diff --git a/diffuser/datasets/__pycache__/sequence.cpython-38.pyc b/diffuser/datasets/__pycache__/sequence.cpython-38.pyc
index ca6f287..c6bfc00 100644
Binary files a/diffuser/datasets/__pycache__/sequence.cpython-38.pyc and b/diffuser/datasets/__pycache__/sequence.cpython-38.pyc differ
diff --git a/diffuser/environments/__pycache__/__init__.cpython-38.pyc b/diffuser/environments/__pycache__/__init__.cpython-38.pyc
index 8e26c4a..4607978 100644
Binary files a/diffuser/environments/__pycache__/__init__.cpython-38.pyc and b/diffuser/environments/__pycache__/__init__.cpython-38.pyc differ
diff --git a/diffuser/environments/__pycache__/registration.cpython-38.pyc b/diffuser/environments/__pycache__/registration.cpython-38.pyc
index 088f973..869fc1b 100644
Binary files a/diffuser/environments/__pycache__/registration.cpython-38.pyc and b/diffuser/environments/__pycache__/registration.cpython-38.pyc differ
diff --git a/diffuser/guides/__pycache__/policies.cpython-38.pyc b/diffuser/guides/__pycache__/policies.cpython-38.pyc
index 475bc22..cb8d2a5 100644
Binary files a/diffuser/guides/__pycache__/policies.cpython-38.pyc and b/diffuser/guides/__pycache__/policies.cpython-38.pyc differ
diff --git a/diffuser/models/__pycache__/__init__.cpython-38.pyc b/diffuser/models/__pycache__/__init__.cpython-38.pyc
index ca1293d..47fc026 100644
Binary files a/diffuser/models/__pycache__/__init__.cpython-38.pyc and b/diffuser/models/__pycache__/__init__.cpython-38.pyc differ
diff --git a/diffuser/models/__pycache__/diffusion.cpython-38.pyc b/diffuser/models/__pycache__/diffusion.cpython-38.pyc
index c92f896..5f9db9b 100644
Binary files a/diffuser/models/__pycache__/diffusion.cpython-38.pyc and b/diffuser/models/__pycache__/diffusion.cpython-38.pyc differ
diff --git a/diffuser/models/__pycache__/helpers.cpython-38.pyc b/diffuser/models/__pycache__/helpers.cpython-38.pyc
index 35b04a7..99b3036 100644
Binary files a/diffuser/models/__pycache__/helpers.cpython-38.pyc and b/diffuser/models/__pycache__/helpers.cpython-38.pyc differ
diff --git a/diffuser/models/__pycache__/temporal.cpython-38.pyc b/diffuser/models/__pycache__/temporal.cpython-38.pyc
index 077b2cb..37df1c5 100644
Binary files a/diffuser/models/__pycache__/temporal.cpython-38.pyc and b/diffuser/models/__pycache__/temporal.cpython-38.pyc differ
diff --git a/diffuser/models/diffusion.py b/diffuser/models/diffusion.py
index 3a1f58d..4b321fd 100644
--- a/diffuser/models/diffusion.py
+++ b/diffuser/models/diffusion.py
@@ -5,6 +5,8 @@ import pdb
 from torch.autograd import Variable
 from qpth.qp import QPFunction, QPSolvers
 import einops
+# import matplotlib
+# matplotlib.use("Agg")  # 强制使用非GUI后端
 
 import diffuser.utils as utils
 from .helpers import (
@@ -99,8 +101,12 @@ class GaussianDiffusion(nn.Module):
         self.model = model
         self.norm_mins = 0
         self.norm_maxs = 0
-        self.safe1 = 0
-        self.safe2 = 0
+        #----------debug safe1 safe2--------
+        #self.safe1 = torch.tensor(0.0)
+        #self.safe2 = torch.tensor(0.0)
+        #-----------------------------------
+        #self.safe1 = 0
+        #self.safe2 = 0
 
         betas = cosine_beta_schedule(n_timesteps)
         alphas = 1. - betas
@@ -255,6 +261,7 @@ class GaussianDiffusion(nn.Module):
         #CBF
         b2 = ((xp1[:,2:3] - off_y)/yr)**4 + ((xp1[:,3:4] - off_x)/xr)**4 - 1
 
+  
         self.safe1 = torch.min(b[:,0])
         self.safe2 = torch.min(b2[:,0])
 
@@ -310,6 +317,106 @@ class GaussianDiffusion(nn.Module):
 
         xp1 = xp1.unsqueeze(0)
         return xp1
+#------------------------------ziyi-----------------------------
+
+    @torch.no_grad()   #only for sampling
+    def Shield_umaze(self, x0, xp10):    ##Truncate method
+        x = x0.clone()
+        xp1 = xp10.clone()
+
+        xp1 = xp1.squeeze(0)
+
+        nBatch = x.shape[0]
+  
+
+        #normalize obstacle 1, x-1, y-0  x = 1/12*np.cos(theta) + 5.5/12, y = 1/9*np.sin(theta) + 5/9
+        xr = 2*1.52/(self.norm_maxs[1] - self.norm_mins[1])
+        yr = 2*1.52/(self.norm_maxs[0] - self.norm_mins[0])
+        off_x = 2*(2.5-0.5 - self.norm_mins[1])/(self.norm_maxs[1] - self.norm_mins[1]) - 1
+        off_y = 2*(2.5-0.5 - self.norm_mins[0])/(self.norm_maxs[0] - self.norm_mins[0]) - 1
+
+        #CBF
+        b = 1 - ((xp1[:,2:3] - off_y)/yr)**4 - ((xp1[:,3:4] - off_x)/xr)**4
+
+         #normalize obstacle 2,  x = 1/12*np.sqrt(np.abs(np.cos(theta)))*np.sign(np.cos(theta)) + 5.3/12, y = 1/9*np.sqrt(np.abs(np.sin(theta)))*np.sign(np.sin(theta)) + 2/9
+        xr = 2*1.2/(self.norm_maxs[1] - self.norm_mins[1])
+        yr = 2*0.6/(self.norm_maxs[0] - self.norm_mins[0])
+        off_x = 2*(2-0.5 - self.norm_mins[1])/(self.norm_maxs[1] - self.norm_mins[1]) - 1
+        off_y = 2*(2.5-0.5 - self.norm_mins[0])/(self.norm_maxs[0] - self.norm_mins[0]) - 1
+
+        #CBF
+  
+        b2 = ((xp1[:,2:3] - off_y)/yr)**4 + ((xp1[:,3:4] - off_x)/xr)**4 - 1
+        
+       
+        for k in range(nBatch):
+            if b2[k, 0] < 0: 
+                theta = torch.atan2((xp1[k,2:3] - off_y)/yr, (xp1[k,3:4] - off_x)/xr)
+                xp1[k,2] = yr*torch.sin(theta) + off_y
+                xp1[k,3] = xr*torch.cos(theta) + off_x
+       
+
+
+        b2 = ((xp1[:,2:3] - off_y)/yr)**4 + ((xp1[:,3:4] - off_x)/xr)**4 - 1
+
+       
+   
+        self.safe1 = torch.min(b[:,0])
+        self.safe2 = torch.min(b2[:,0])
+
+        xp1 = xp1.unsqueeze(0)
+        return xp1
+    
+    @torch.no_grad()   #only for sampling
+    def GD_umaze(self, x0, xp10):    #classifier guidance or potential-based method
+
+        x = x0.clone()
+        xp1 = xp10.clone()
+
+        x = x.squeeze(0)
+        xp1 = xp1.squeeze(0)
+
+        nBatch = x.shape[0]
+        ref = xp1 - x
+
+        #normalize obstacle 1, x-1, y-0  x = 1/12*np.cos(theta) + 5.5/12, y = 1/9*np.sin(theta) + 5/9
+        xr = 2*1.52/(self.norm_maxs[1] - self.norm_mins[1])
+        yr = 2*1.52/(self.norm_maxs[0] - self.norm_mins[0])
+        off_x = 2*(2.5-0.5 - self.norm_mins[1])/(self.norm_maxs[1] - self.norm_mins[1]) - 1
+        off_y = 2*(2.5-0.5 - self.norm_mins[0])/(self.norm_maxs[0] - self.norm_mins[0]) - 1
+
+        #CBF
+        b = 1 - ((xp1[:,2:3] - off_y)/yr)**4 - ((xp1[:,3:4] - off_x)/xr)**4
+       
+        
+
+        #normalize obstacle 2,  x = 1/12*np.sqrt(np.abs(np.cos(theta)))*np.sign(np.cos(theta)) + 5.3/12, y = 1/9*np.sqrt(np.abs(np.sin(theta)))*np.sign(np.sin(theta)) + 2/9
+        xr = 2*1.2/(self.norm_maxs[1] - self.norm_mins[1])
+        yr = 2*0.6/(self.norm_maxs[0] - self.norm_mins[0])
+        off_x = 2*(2-0.5 - self.norm_mins[1])/(self.norm_maxs[1] - self.norm_mins[1]) - 1
+        off_y = 2*(2.5-0.5 - self.norm_mins[0])/(self.norm_maxs[0] - self.norm_mins[0]) - 1
+
+        #CBF
+        b2 = ((xp1[:,2:3] - off_y)/yr)**4 + ((xp1[:,3:4] - off_x)/xr)**4 - 1
+    
+        for k in range(nBatch):
+            if b[k, 0] < 0.1:  # 0, 0.2
+                u1 = 0.2/(2*((xp1[k,2:3] - off_y)/yr)/yr)
+                u2 = 0.2/(2*((xp1[k,3:4] - off_x)/xr)/xr)
+                xp1[k,2] = xp1[k,2] + u1*0.001  #note no 0.1/0.01 for GD, but has for potential
+                xp1[k,3] = xp1[k,3] + u2*0.001
+            elif b2[k, 0] < 0.1:  # 0, 0.2
+                u1 = 0.2/(4*((xp1[k,2:3] - off_y)/yr)**3/yr)
+                u2 = 0.2/(4*((xp1[k,3:4] - off_x)/xr)**3/xr)
+                xp1[k,2] = xp1[k,2] + u1*0.001
+                xp1[k,3] = xp1[k,3] + u2*0.001
+
+        self.safe1 = torch.min(b[:,0])
+        self.safe2 = torch.min(b2[:,0])
+
+        xp1 = xp1.unsqueeze(0)
+        return xp1
+#---------------------------------ziyi--------------------------------------------------------------
 
     @torch.no_grad()   #only for sampling
     def invariance_umaze(self, x, xp1):   #  RoS-diffuser for umaze
@@ -1026,9 +1133,48 @@ class GaussianDiffusion(nn.Module):
         # print(out)
         rt = rt.unsqueeze(0)
         return rt        
+    
+        ####----------------------------------------ziyi-------------------------------------
+    def original_diffuser(self, x, xp1): #original diffuser only  maze2d-large-v1
+        x = xp1
+        xr = 2 * 1 / (self.norm_maxs[1] - self.norm_mins[1])
+        yr = 2 * 1 / (self.norm_maxs[0] - self.norm_mins[0])
+        off_x = 2 * (5.8 - 0.5 - self.norm_mins[1]) / (self.norm_maxs[1] - self.norm_mins[1]) - 1
+        off_y = 2 * (5 - 0.5 - self.norm_mins[0]) / (self.norm_maxs[0] - self.norm_mins[0]) - 1
+        b = ((x[:, 2:3] - off_y) / yr) ** 2 + ((x[:, 3:4] - off_x) / xr) ** 2 - 1
+        self.safe1 = torch.min(b[:, 0])
+        
+        xr = 2 * 1 / (self.norm_maxs[1] - self.norm_mins[1])
+        yr = 2 * 1 / (self.norm_maxs[0] - self.norm_mins[0])
+        off_x = 2 * (5.3 - 0.5 - self.norm_mins[1]) / (self.norm_maxs[1] - self.norm_mins[1]) - 1
+        off_y = 2 * (2 - 0.5 - self.norm_mins[0]) / (self.norm_maxs[0] - self.norm_mins[0]) - 1
+        b2 = ((x[:, 2:3] - off_y) / yr) ** 4 + ((x[:, 3:4] - off_x) / xr) ** 4 - 1
+        self.safe2 = torch.min(b2[:, 0])
+        return x
+    
+    def original_diffuser_umaze(self, x, xp1): #original diffuser only  maze2d-umaze-v1
+        #x = xp1
+        xr = 2*1.52/(self.norm_maxs[1] - self.norm_mins[1])
+        yr = 2*1.52/(self.norm_maxs[0] - self.norm_mins[0])
+        off_x = 2*(2.5-0.5 - self.norm_mins[1])/(self.norm_maxs[1] - self.norm_mins[1]) - 1
+        off_y = 2*(2.5-0.5 - self.norm_mins[0])/(self.norm_maxs[0] - self.norm_mins[0]) - 1
+        b = 1 - ((x[:,2:3] - off_y)/yr)**4 - ((x[:,3:4] - off_x)/xr)**4 
+        self.safe1 = torch.min(b[:, 0])
+        
+        xr = 2*1.2/(self.norm_maxs[1] - self.norm_mins[1])
+        yr = 2*0.6/(self.norm_maxs[0] - self.norm_mins[0])
+        off_x = 2*(2-0.5 - self.norm_mins[1])/(self.norm_maxs[1] - self.norm_mins[1]) - 1
+        off_y = 2*(2.5-0.5 - self.norm_mins[0])/(self.norm_maxs[0] - self.norm_mins[0]) - 1
+        b2 = ((x[:, 2:3] - off_y) / yr) ** 4 + ((x[:, 3:4] - off_x) / xr) ** 4 - 1
+        self.safe2 = torch.min(b2[:, 0])
+        return x
+    
+        ###-------------------------------------------ziyi--------------------------------------
+
+
 
     @torch.no_grad()
-    def p_sample(self, x, cond, t):
+    def p_sample(self, x, cond, t, diffuser_choice = 15):
         b, *_, device = *x.shape, x.device
         model_mean, _, model_log_variance = self.p_mean_variance(x=x, cond=cond, t=t)
         noise = torch.randn_like(x)
@@ -1037,6 +1183,36 @@ class GaussianDiffusion(nn.Module):
 
         xp1 = model_mean + nonzero_mask * (0.5 * model_log_variance).exp() * noise
 
+
+
+        ####----------------------------------------------ziyi------------------------------------------------
+        
+        diffuser_methods = {
+            1: lambda x, xp1, t: self.original_diffuser(x, xp1),
+            2: lambda x, xp1, t: self.GD(x, xp1),
+            3: lambda x, xp1, t: self.Shield(x, xp1),
+            4: lambda x, xp1, t: self.invariance(x, xp1), #local trap
+            5: lambda x, xp1, t: self.invariance_cf(x, xp1), #local trap
+            6: lambda x, xp1, t: self.invariance_relax(x, xp1, t),
+            7: lambda x, xp1, t: self.invariance_relax_cf(x, xp1, t),
+            8: lambda x, xp1, t: self.invariance_time(x, xp1, t), #
+            9: lambda x, xp1, t: self.invariance_time_cf(x, xp1, t), #
+            10: lambda x, xp1, t: self.invariance_relax_narrow(x, xp1, t),
+            11: lambda x, xp1, t: self.GD_umaze(x, xp1),
+            12: lambda x, xp1, t: self.Shield_umaze(x, xp1),
+            13: lambda x, xp1, t: self.invariance_umaze(x, xp1), #local trap
+            14: lambda x, xp1, t: self.invariance_umaze_relax(x, xp1, t),
+            15: lambda x, xp1, t: self.original_diffuser_umaze(x, xp1)
+        }
+
+        x = diffuser_methods.get(diffuser_choice, lambda x, xp1, t: xp1)(x, xp1, t)
+        return x
+    
+        ####--------------------------------------------ziyi-------------------------------------------------
+
+
+
+
         # Note:  choose any one of the below
         #---------------------------------------start--------------------------------------------------#
         ####################### original diffuser only
@@ -1059,7 +1235,7 @@ class GaussianDiffusion(nn.Module):
         # x = self.GD(x, xp1)
 
         ####################### SafeDiffusers 
-        x = xp1 # for training only
+        # x = xp1 # for training only
         # x = self.invariance(x, xp1)    # RoS
         # x = self.invariance_cf(x, xp1)  # RoS closed form
         # x = self.invariance_relax(x, xp1, t) # ReS
@@ -1067,7 +1243,8 @@ class GaussianDiffusion(nn.Module):
         # x = self.invariance_time(x, xp1, t)   # TVS
         # x = self.invariance_time_cf(x, xp1, t)  # TVS closed form
         # x = self.invariance_relax_narrow(x, xp1, t)  # narrow passage case
-
+        
+      
         ####################### Applying SafeDiffusers to only the last 10 steps
         # if t <= 10:  #10
         #     # x = self.invariance_relax(x, xp1, t)  #done
@@ -1107,29 +1284,33 @@ class GaussianDiffusion(nn.Module):
         if return_diffusion: diffusion = [x]
 
         progress = utils.Progress(self.n_timesteps) if verbose else utils.Silent()
+        #------------debug--------------------
         safe1, safe2 = [], []
+        #-----------------------------------
         for i in reversed(range(0, self.n_timesteps)):  #-50 change here for the number of diffusion steps,
             if i < 0:
                 i = 0
             timesteps = torch.full((batch_size,), i, device=device, dtype=torch.long)
             x = self.p_sample(x, cond, timesteps)
             x = apply_conditioning(x, cond, self.action_dim)
+            #--------------debug-----------------
             safe1.append(self.safe1.unsqueeze(0))
             safe2.append(self.safe2.unsqueeze(0))
+            #------------------------------
             progress.update({'t': i})
 
             if return_diffusion: diffusion.append(x)
-        
+        #--------------debug----------------
         self.safe1 = torch.cat(safe1, dim=0)
         self.safe2 = torch.cat(safe2, dim=0)
-
+        #------------------------------------
         progress.close()
         # pdb.set_trace()
         if return_diffusion:
             return x, torch.stack(diffusion, dim=1)
         else:
             return x
-
+    
     @torch.no_grad()
     def conditional_sample(self, cond, *args, horizon=None, return_diffusion = True, **kwargs):
         '''
diff --git a/diffuser/utils/__pycache__/__init__.cpython-38.pyc b/diffuser/utils/__pycache__/__init__.cpython-38.pyc
index 649cd85..8180862 100644
Binary files a/diffuser/utils/__pycache__/__init__.cpython-38.pyc and b/diffuser/utils/__pycache__/__init__.cpython-38.pyc differ
diff --git a/diffuser/utils/__pycache__/arrays.cpython-38.pyc b/diffuser/utils/__pycache__/arrays.cpython-38.pyc
index 7144fbf..90ce517 100644
Binary files a/diffuser/utils/__pycache__/arrays.cpython-38.pyc and b/diffuser/utils/__pycache__/arrays.cpython-38.pyc differ
diff --git a/diffuser/utils/__pycache__/cloud.cpython-38.pyc b/diffuser/utils/__pycache__/cloud.cpython-38.pyc
index ea9cd0b..c090e7b 100644
Binary files a/diffuser/utils/__pycache__/cloud.cpython-38.pyc and b/diffuser/utils/__pycache__/cloud.cpython-38.pyc differ
diff --git a/diffuser/utils/__pycache__/colab.cpython-38.pyc b/diffuser/utils/__pycache__/colab.cpython-38.pyc
index 69269aa..436d965 100644
Binary files a/diffuser/utils/__pycache__/colab.cpython-38.pyc and b/diffuser/utils/__pycache__/colab.cpython-38.pyc differ
diff --git a/diffuser/utils/__pycache__/config.cpython-38.pyc b/diffuser/utils/__pycache__/config.cpython-38.pyc
index 1c923cf..3de5e23 100644
Binary files a/diffuser/utils/__pycache__/config.cpython-38.pyc and b/diffuser/utils/__pycache__/config.cpython-38.pyc differ
diff --git a/diffuser/utils/__pycache__/git_utils.cpython-38.pyc b/diffuser/utils/__pycache__/git_utils.cpython-38.pyc
index 3ef2826..0305106 100644
Binary files a/diffuser/utils/__pycache__/git_utils.cpython-38.pyc and b/diffuser/utils/__pycache__/git_utils.cpython-38.pyc differ
diff --git a/diffuser/utils/__pycache__/progress.cpython-38.pyc b/diffuser/utils/__pycache__/progress.cpython-38.pyc
index aed1a83..4a8109f 100644
Binary files a/diffuser/utils/__pycache__/progress.cpython-38.pyc and b/diffuser/utils/__pycache__/progress.cpython-38.pyc differ
diff --git a/diffuser/utils/__pycache__/rendering.cpython-38.pyc b/diffuser/utils/__pycache__/rendering.cpython-38.pyc
index d4d8733..f16e15e 100644
Binary files a/diffuser/utils/__pycache__/rendering.cpython-38.pyc and b/diffuser/utils/__pycache__/rendering.cpython-38.pyc differ
diff --git a/diffuser/utils/__pycache__/serialization.cpython-38.pyc b/diffuser/utils/__pycache__/serialization.cpython-38.pyc
index 6569e85..f848271 100644
Binary files a/diffuser/utils/__pycache__/serialization.cpython-38.pyc and b/diffuser/utils/__pycache__/serialization.cpython-38.pyc differ
diff --git a/diffuser/utils/__pycache__/setup.cpython-38.pyc b/diffuser/utils/__pycache__/setup.cpython-38.pyc
index 6c688a6..0c8ecf3 100644
Binary files a/diffuser/utils/__pycache__/setup.cpython-38.pyc and b/diffuser/utils/__pycache__/setup.cpython-38.pyc differ
diff --git a/diffuser/utils/__pycache__/timer.cpython-38.pyc b/diffuser/utils/__pycache__/timer.cpython-38.pyc
index 5d0828d..b6b2770 100644
Binary files a/diffuser/utils/__pycache__/timer.cpython-38.pyc and b/diffuser/utils/__pycache__/timer.cpython-38.pyc differ
diff --git a/diffuser/utils/__pycache__/training.cpython-38.pyc b/diffuser/utils/__pycache__/training.cpython-38.pyc
index 60a777a..74c56c3 100644
Binary files a/diffuser/utils/__pycache__/training.cpython-38.pyc and b/diffuser/utils/__pycache__/training.cpython-38.pyc differ
diff --git a/diffuser/utils/__pycache__/video.cpython-38.pyc b/diffuser/utils/__pycache__/video.cpython-38.pyc
index 7272778..e2f9411 100644
Binary files a/diffuser/utils/__pycache__/video.cpython-38.pyc and b/diffuser/utils/__pycache__/video.cpython-38.pyc differ
diff --git a/diffuser/utils/rendering.py b/diffuser/utils/rendering.py
index 6b3bb81..8c73388 100644
--- a/diffuser/utils/rendering.py
+++ b/diffuser/utils/rendering.py
@@ -299,8 +299,21 @@ class MazeRenderer:
 
         # Note:  choose any one of the below
         #---------------------------------------start--------------------------------------------------#
+
+#######----------------------Ziyi-----------------------------------
+        maze_obstacles = {
+        0: lambda: self._draw_large_v1_maze(),
+        1: lambda: self._draw_narrow_maze(),
+        2: lambda: self._draw_umaze()
+        }
+        maze_type = 2
+        maze_obstacles[maze_type]()
+######----------------------Ziyi------------------------------------
+        
         #################################################### maze-large-v1
+        '''
         theta = np.linspace(0,2*np.pi, 100)
+        
         x = 1/12*np.cos(theta) + 5.8/12  #5.5
         y = 1/9*np.sin(theta) + 5/9
         plt.plot(x, y, c='red', zorder = 10)
@@ -308,59 +321,125 @@ class MazeRenderer:
         x = 1/12*np.sqrt(np.abs(np.cos(theta)))*np.sign(np.cos(theta)) + 5.3/12
         y = 1/9*np.sqrt(np.abs(np.sin(theta)))*np.sign(np.sin(theta)) + 2/9
         plt.plot(x, y, c='red', zorder = 10)
-
+        '''
         # ###################### maze-large-v1 more obstacles - narrow passage
-        # x = 1/12*np.sqrt(np.abs(np.cos(theta)))*np.sign(np.cos(theta)) + 5.5/12
-        # y = 1/9*np.sqrt(np.abs(np.sin(theta)))*np.sign(np.sin(theta)) + 2/9
-        # plt.plot(x, y, c='red', zorder = 10)
-        # plt.fill(x, y, "red", alpha = 0.3)
-
-        # theta = np.linspace(0,2*np.pi, 100)
-        # x = 1/12*np.sqrt(np.abs(np.cos(theta)))*np.sign(np.cos(theta)) + 5.5/12
-        # y = 1/9*np.sqrt(np.abs(np.sin(theta)))*np.sign(np.sin(theta)) + 5/9
-        # plt.plot(x, y, c='red', zorder = 10)
-        # plt.fill(x, y, "red", alpha = 0.3)
-
-        # theta = np.linspace(0,2*np.pi, 100)
-        # x = 1/12*np.sqrt(np.abs(np.cos(theta)))*np.sign(np.cos(theta)) + 3/12
-        # y = 0.5*1/9*np.sqrt(np.abs(np.sin(theta)))*np.sign(np.sin(theta)) + 2.5/9
-        # plt.plot(x, y, c='red', zorder = 10)
-        # plt.fill(x, y, "red", alpha = 0.3)
-
-        # theta = np.linspace(0,2*np.pi, 100)
-        # x = 1.8*1/12*np.sqrt(np.abs(np.cos(theta)))*np.sign(np.cos(theta)) + 8.5/12
-        # y = 1.8*1/9*np.sqrt(np.abs(np.sin(theta)))*np.sign(np.sin(theta)) + 3.5/9
-        # plt.plot(x, y, c='red', zorder = 10)
-        # plt.fill(x, y, "red", alpha = 0.3)
-
-        # theta = np.linspace(0,2*np.pi, 100)
-        # x = 1/12*np.sqrt(np.abs(np.cos(theta)))*np.sign(np.cos(theta)) + 7.6/12
-        # y = 1/9*np.sqrt(np.abs(np.sin(theta)))*np.sign(np.sin(theta)) + 7/9
-        # plt.plot(x, y, c='red', zorder = 10)
-        # plt.fill(x, y, "red", alpha = 0.3)
-
-        # theta = np.linspace(0,2*np.pi, 100)
-        # x = 1/12*np.sqrt(np.abs(np.cos(theta)))*np.sign(np.cos(theta)) + 10/12
-        # y = 1/9*np.sqrt(np.abs(np.sin(theta)))*np.sign(np.sin(theta)) + 6.3/9
-        # plt.plot(x, y, c='red', zorder = 10)
-        # plt.fill(x, y, "red", alpha = 0.3)
+        '''
+        theta = np.linspace(0,2*np.pi, 100)
+        
+        x = 1/12*np.sqrt(np.abs(np.cos(theta)))*np.sign(np.cos(theta)) + 5.5/12
+        y = 1/9*np.sqrt(np.abs(np.sin(theta)))*np.sign(np.sin(theta)) + 2/9
+        plt.plot(x, y, c='red', zorder = 10)
+        plt.fill(x, y, "red", alpha = 0.3)
+
+        theta = np.linspace(0,2*np.pi, 100)
+        x = 1/12*np.sqrt(np.abs(np.cos(theta)))*np.sign(np.cos(theta)) + 5.5/12
+        y = 1/9*np.sqrt(np.abs(np.sin(theta)))*np.sign(np.sin(theta)) + 5/9
+        plt.plot(x, y, c='red', zorder = 10)
+        plt.fill(x, y, "red", alpha = 0.3)
+
+        theta = np.linspace(0,2*np.pi, 100)
+        x = 1/12*np.sqrt(np.abs(np.cos(theta)))*np.sign(np.cos(theta)) + 3/12
+        y = 0.5*1/9*np.sqrt(np.abs(np.sin(theta)))*np.sign(np.sin(theta)) + 2.5/9
+        plt.plot(x, y, c='red', zorder = 10)
+        plt.fill(x, y, "red", alpha = 0.3)
+
+        theta = np.linspace(0,2*np.pi, 100)
+        x = 1.8*1/12*np.sqrt(np.abs(np.cos(theta)))*np.sign(np.cos(theta)) + 8.5/12
+        y = 1.8*1/9*np.sqrt(np.abs(np.sin(theta)))*np.sign(np.sin(theta)) + 3.5/9
+        plt.plot(x, y, c='red', zorder = 10)
+        plt.fill(x, y, "red", alpha = 0.3)
+
+        theta = np.linspace(0,2*np.pi, 100)
+        x = 1/12*np.sqrt(np.abs(np.cos(theta)))*np.sign(np.cos(theta)) + 7.6/12
+        y = 1/9*np.sqrt(np.abs(np.sin(theta)))*np.sign(np.sin(theta)) + 7/9
+        plt.plot(x, y, c='red', zorder = 10)
+        plt.fill(x, y, "red", alpha = 0.3)
+
+        theta = np.linspace(0,2*np.pi, 100)
+        x = 1/12*np.sqrt(np.abs(np.cos(theta)))*np.sign(np.cos(theta)) + 10/12
+        y = 1/9*np.sqrt(np.abs(np.sin(theta)))*np.sign(np.sin(theta)) + 6.3/9
+        plt.plot(x, y, c='red', zorder = 10)
+        plt.fill(x, y, "red", alpha = 0.3)'''
 
         ###################################################  umaze
-        # theta = np.linspace(0,2*np.pi, 100)
-        # x = 1.2/5*np.sqrt(np.abs(np.cos(theta)))*np.sign(np.cos(theta)) + 2/5
-        # y = 0.6/5*np.sqrt(np.abs(np.sin(theta)))*np.sign(np.sin(theta)) + 2.5/5
-        # plt.plot(x, y, c='red', zorder = 10)
-
-        # theta = np.linspace(0,2*np.pi, 100)
-        # x = 1.52/5*np.sqrt(np.abs(np.cos(theta)))*np.sign(np.cos(theta)) + 2.5/5
-        # y = 1.52/5*np.sqrt(np.abs(np.sin(theta)))*np.sign(np.sin(theta)) + 2.5/5
-        # plt.plot(x, y, c='green', zorder = 10)
-        #---------------------------------------end--------------------------------------------------#
+        '''
+        theta = np.linspace(0,2*np.pi, 100)
+        x = 1.2/5*np.sqrt(np.abs(np.cos(theta)))*np.sign(np.cos(theta)) + 2/5
+        y = 0.6/5*np.sqrt(np.abs(np.sin(theta)))*np.sign(np.sin(theta)) + 2.5/5
+        plt.plot(x, y, c='red', zorder = 10)
 
+        theta = np.linspace(0,2*np.pi, 100)
+        x = 1.52/5*np.sqrt(np.abs(np.cos(theta)))*np.sign(np.cos(theta)) + 2.5/5
+        y = 1.52/5*np.sqrt(np.abs(np.sin(theta)))*np.sign(np.sin(theta)) + 2.5/5
+        plt.plot(x, y, c='green', zorder = 10)'''
+        #---------------------------------------end--------------------------------------------------#
+        
         plt.axis('off')
         plt.title(title)
         img = plot2img(fig, remove_margins=self._remove_margins)
         return img
+##########----------------------------Ziyi----------------------------
+    def _draw_large_v1_maze(self):
+        theta = np.linspace(0,2*np.pi, 100)
+        
+        x = 1/12*np.cos(theta) + 5.8/12  #5.5
+        y = 1/9*np.sin(theta) + 5/9
+        plt.plot(x, y, c='red', zorder = 10)
+
+        x = 1/12*np.sqrt(np.abs(np.cos(theta)))*np.sign(np.cos(theta)) + 5.3/12
+        y = 1/9*np.sqrt(np.abs(np.sin(theta)))*np.sign(np.sin(theta)) + 2/9
+        plt.plot(x, y, c='red', zorder = 10)
+
+    def _draw_narrow_maze(self):
+        theta = np.linspace(0,2*np.pi, 100)
+        
+        x = 1/12*np.sqrt(np.abs(np.cos(theta)))*np.sign(np.cos(theta)) + 5.5/12
+        y = 1/9*np.sqrt(np.abs(np.sin(theta)))*np.sign(np.sin(theta)) + 2/9
+        plt.plot(x, y, c='red', zorder = 10)
+        plt.fill(x, y, "red", alpha = 0.3)
+
+        theta = np.linspace(0,2*np.pi, 100)
+        x = 1/12*np.sqrt(np.abs(np.cos(theta)))*np.sign(np.cos(theta)) + 5.5/12
+        y = 1/9*np.sqrt(np.abs(np.sin(theta)))*np.sign(np.sin(theta)) + 5/9
+        plt.plot(x, y, c='red', zorder = 10)
+        plt.fill(x, y, "red", alpha = 0.3)
+
+        theta = np.linspace(0,2*np.pi, 100)
+        x = 1/12*np.sqrt(np.abs(np.cos(theta)))*np.sign(np.cos(theta)) + 3/12
+        y = 0.5*1/9*np.sqrt(np.abs(np.sin(theta)))*np.sign(np.sin(theta)) + 2.5/9
+        plt.plot(x, y, c='red', zorder = 10)
+        plt.fill(x, y, "red", alpha = 0.3)
+
+        theta = np.linspace(0,2*np.pi, 100)
+        x = 1.8*1/12*np.sqrt(np.abs(np.cos(theta)))*np.sign(np.cos(theta)) + 8.5/12
+        y = 1.8*1/9*np.sqrt(np.abs(np.sin(theta)))*np.sign(np.sin(theta)) + 3.5/9
+        plt.plot(x, y, c='red', zorder = 10)
+        plt.fill(x, y, "red", alpha = 0.3)
+
+        theta = np.linspace(0,2*np.pi, 100)
+        x = 1/12*np.sqrt(np.abs(np.cos(theta)))*np.sign(np.cos(theta)) + 7.6/12
+        y = 1/9*np.sqrt(np.abs(np.sin(theta)))*np.sign(np.sin(theta)) + 7/9
+        plt.plot(x, y, c='red', zorder = 10)
+        plt.fill(x, y, "red", alpha = 0.3)
+
+        theta = np.linspace(0,2*np.pi, 100)
+        x = 1/12*np.sqrt(np.abs(np.cos(theta)))*np.sign(np.cos(theta)) + 10/12
+        y = 1/9*np.sqrt(np.abs(np.sin(theta)))*np.sign(np.sin(theta)) + 6.3/9
+        plt.plot(x, y, c='red', zorder = 10)
+        plt.fill(x, y, "red", alpha = 0.3)
+
+    def _draw_umaze(self):
+        theta = np.linspace(0,2*np.pi, 100)
+        x = 1.2/5*np.sqrt(np.abs(np.cos(theta)))*np.sign(np.cos(theta)) + 2/5
+        y = 0.6/5*np.sqrt(np.abs(np.sin(theta)))*np.sign(np.sin(theta)) + 2.5/5
+        plt.plot(x, y, c='red', zorder = 10)
+
+        theta = np.linspace(0,2*np.pi, 100)
+        x = 1.52/5*np.sqrt(np.abs(np.cos(theta)))*np.sign(np.cos(theta)) + 2.5/5
+        y = 1.52/5*np.sqrt(np.abs(np.sin(theta)))*np.sign(np.sin(theta)) + 2.5/5
+        plt.plot(x, y, c='green', zorder = 10)
+    ########------------------------Ziyi--------------------------------
+
 
     def composite(self, savepath, paths, ncol=5, **kwargs):
         '''
diff --git a/scripts/plan_maze2d.py b/scripts/plan_maze2d.py
index f914718..a22026d 100644
--- a/scripts/plan_maze2d.py
+++ b/scripts/plan_maze2d.py
@@ -8,6 +8,10 @@ from diffuser.guides.policies import Policy
 import diffuser.datasets as datasets
 import diffuser.utils as utils
 import torch
+import random
+# import matplotlib
+# matplotlib.use("Agg")  # 强制使用非GUI后端
+
 
 #export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/lib/nvidia-515
 #export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/wei/.mujoco/mujoco200/bin
@@ -19,7 +23,7 @@ class Parser(utils.Parser):
     config: str = 'config.maze2d'
 
 
-os.environ['CUDA_VISIBLE_DEVICES'] = '0'
+#os.environ['CUDA_VISIBLE_DEVICES'] = '0'
 
 #---------------------------------- setup ----------------------------------#
 
@@ -52,18 +56,107 @@ def smooth(diffusion):
     
     return diffusion_copy
 
+
+#--------------------------------------ziyi---------------------------------------
+mode = 15 # Change this to 1-12 as needed
+modes = {
+    1: "diffuser",
+    2: "GD",
+    3: "Shield",
+    4: "invariance",#local trap
+    5: "invariance_cf",#local trap
+    6: "invariance_relax",
+    7: "invariance_relax_cf",
+    8: "invariance_time",
+    9: "invariance_time_cf",
+    10: "invariance_relax_narrow",
+    11: "GD_umaze",
+    12: "Shield_umaze",
+    13: "invariance_umaze",
+    14: "invariance_umaze_relax",
+    15: "diffuser_umaze"
+}
+sub_dir = join(args.savepath, modes.get(mode, "default"))
+makedirs(sub_dir)
+#-------------------------------------------------------------------------------
 #---------------------------------- main loop ----------------------------------#
 safe1_batch, safe2_batch = [], []
 score_batch = []
 comp_time = []
 elbo_batch = []
 success = 0
+
+#--------------ziyi---customize-------------------------------
+all_observations = []
+all_targets = []
+all_diffusion_sm = []
+all_actions = []
+all_observations_env = []
+all_actions_env = []
+
+#all_next_observations = []
+#--------------ziyi---customize-------------------------------
+
+####--------------------ziyi---------fix---------------observation------------initial position--------------------------------------------------------------
+    
+
+observation_large = {
+    0 : [ 1.0195254,   2.37341661,  0,          0        ],
+    1 : [1.04110535,   1.998743,   0,         0        ],
+    2 : [4.06317071e+00,  9.90054770e+00, -2.32503077e-01, -2.18791664e-02],
+    3 : [7.04593109,  7.93513112, -0.0544259,  -0.03163002],
+    4 : [0.96946192,  2.22096705,  0,          0        ],
+    5 : [2.02943790e+00,  1.00230770e+01,  9.40122978e-03, -7.43499249e-02],
+    6 : [6.0371084,   8.03009186, -0.10096182, -0.02091756],
+    7 : [6.9270193,   9.04429767,  0.02146591,  0.03553727],
+    8 : [3.07789757,  6.0868087,   0.14934311, -0.12590655],
+    9 : [2.96437388, 10.01886001,  0.07813114,  0.02644556]
+    }
+observation_umaze = {
+    0 : [ 2.95395734,  2.9081947,   0.01049001, -0.05356694],
+    1 : [ 3.08255112,  2.02132716,  0.0947081,  -0.07037352], 
+    2 : [ 3.06317071,  0.9005477,  -0.23250308, -0.02187917],
+    3 : [ 1.04593109,  0.93513112, -0.0544259,  -0.03163002],
+    4 : [ 0.98453744,  1.90566393,  0.13664635, -0.06651947],
+    5 : [ 2.0294379,   3.02307702,  0.00940123, -0.07434992],
+    6 : [ 3.0371084,   3.03009186, -0.10096182, -0.02091756],
+    7 : [ 0.9270193,   1.04429767,  0.02146591,  0.03553727],
+    8 : [ 2.07789757,  3.0868087,   0.14934311, -0.12590655],
+    9 : [ 2.96437388,  1.01886001,  0.07813114,  0.02644556]
+    }
+####-----------------------------ziyi---------fix---------------observation------------initial position----------------------------------------------------------
+
+seeds = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
+#seeds = [7]
 import time
-for iter in range(1):   # num of testing runs
-    print("step: ", iter, "/100")
+for iter in range(10):   # num of testing runs
+    print("step: ", iter, "/10")
+
+
+    seed = seeds[iter]
+    random.seed(seed)
+    env.seed(seed)
+    np.random.seed(seed)
+    torch.manual_seed(seed)
 
     observation = env.reset()    #array([ 0.94875744,  8.93648809, -0.01347715,  0.06358764])
-    observation = np.array([ 0.94875744,  2.93648809, -0.01347715,  0.06358764])   # fix the initial position and final destination for comparison (not needed for general testing)
+    # observation = np.array([ 0.94875744,  2.93648809, -0.01347715,  0.06358764])   # fix the initial position and final destination for comparison (not needed for general testing)
+    
+    dataset_choice = 1
+    if dataset_choice == 0:
+        selected_dict = observation_large
+    elif dataset_choice == 1:
+        selected_dict = observation_umaze
+ 
+
+    # 从选定的字典中获取 observation
+    initial_observation_list = selected_dict[iter]
+
+    # 将列表转换为 NumPy 数组
+    initial_observation = np.array(initial_observation_list)
+    # ---------------ziyi debug-----large GD第7组
+    #initial_observation = np.array([ 0.9270193,   1.04429767,  0.02146591,  0.03553727])
+    #######-------------------------
     env.set_state(observation[0:2], observation[2:4]) ############################################################ same as the last line
 
     if args.conditional:
@@ -79,6 +172,13 @@ for iter in range(1):   # num of testing runs
     ## observations for rendering
     rollout = [observation.copy()]
 
+
+    #--------------------------ziyi---------------------------
+    actions_iter = []  # Collect actions for this iteration
+    next_observations_iter = []  # New: Collect next_observations for this iteration
+    #-------------------------ziyi-------------------------
+
+
     total_reward = 0
     for t in range(env.max_episode_steps):
 
@@ -100,25 +200,36 @@ for iter in range(1):   # num of testing runs
             # action, samples, diffusion_paths, safe1, safe2 = policy(cond, batch_size=args.batch_size)  #policy.normalizer.normalizers['observations'].mins
             actions = samples.actions[0]
             sequence = samples.observations[0]
-            diffusion_paths = diffusion_paths[0]
+            diffusion_sm = diffusion_paths[0]
+
+            #------------------------ziyi-------------------------------
+            
+            all_observations.append(sequence)
+            all_diffusion_sm.append(diffusion_sm)
+
+            all_actions.append(actions)
+            #------------------------ziyi-------------------------------
 
             
             ##################################################save videos/images
-            fullpath = join(args.savepath, f'{iter}.png')
+            fullpath = join(sub_dir, f'{iter}.png')
             renderer.composite(fullpath, samples.observations, ncol=1)
             #########################################s################# 8/3/2023
             # diffusion_sm = smooth(diffusion_paths)    # smooth the generated traj.
             diffusion_sm = diffusion_paths            # do not smooth the generated traj.
-            renderer.render_diffusion(join(args.savepath, f'diffusion.mp4'), diffusion_sm)
+
+            #-----------------customize-------------------------------
+            #renderer.render_diffusion(join(sub_dir, f'diffusion.mp4'), diffusion_sm)
+            #---------------------------------------------------------
 
             # makedirs(join(args.savepath, 'trap'))
             # fullpath = join(args.savepath, f'trap/{iter}.png')
             # renderer.composite(fullpath, samples.observations, ncol=1)
 
             diff_step = diffusion_sm.shape[0]  
-            makedirs(join(args.savepath, 'png'))
+            makedirs(join(sub_dir, 'png'))
             for kk in range(diff_step):
-                imgpath = join(args.savepath, f'png/{kk}.png')
+                imgpath = join(sub_dir, f'png/{kk}.png')
                 renderer.composite(imgpath, diffusion_sm[kk:kk+1], ncol=1)
             ##################################################end saving videos/images
 
@@ -132,7 +243,11 @@ for iter in range(1):   # num of testing runs
 
         ## can use actions or define a simple controller based on state predictions
         action = next_waypoint[:2] - state[:2] + (next_waypoint[2:] - state[2:])
-        
+
+        #------------------------------ziyi--------Collect action------------
+        actions_iter.append(action)
+        #------------------------------ziyi---------------------
+
         # else:
         #     actions = actions[1:]
         #     if len(actions) > 1:
@@ -145,6 +260,10 @@ for iter in range(1):   # num of testing runs
 
 
         next_observation, reward, terminal, _ = env.step(action)
+        #------------------------------ziyi--------Collect next_observation------------
+        next_observations_iter.append(next_observation)
+        #------------------------------ziyi---------------------
+
         total_reward += reward
         score = env.get_normalized_score(total_reward)
 
@@ -153,14 +272,14 @@ for iter in range(1):   # num of testing runs
         #     f't: {t} | r: {reward:.2f} |  R: {total_reward:.2f} | score: {score:.4f} | '
         #     f'{action}'
         # )
-
-        # if 'maze2d' in args.dataset:
-        #     xy = next_observation[:2]
-        #     goal = env.unwrapped._target
-        #     print(
-        #         f'maze | pos: {xy} | goal: {goal}'
-        #     )
-
+#--------------------ziyi target---
+        if 'maze2d' in args.dataset:
+             xy = next_observation[:2]
+             goal = env.unwrapped._target
+             print(
+                 f'maze | pos: {xy} | goal: {goal}'
+             )
+#--------------
         ## update rollout observations
         rollout.append(next_observation.copy())
 
@@ -192,11 +311,54 @@ for iter in range(1):   # num of testing runs
 
     # score = 0
 
+    #---------------------ziyi------------Collect data for this iteration---------------------------
+    
+    all_targets.append(target)
+    all_actions_env.append(np.array(actions_iter))
+    all_observations_env.append(np.array(next_observations_iter))  # New: Append collected next_observations
+    #----------------------ziyi---------------------------------------------------------------------
+
     safe1_batch.append(torch.cat([safe1[-1].unsqueeze(0).unsqueeze(0), torch.tensor(score).unsqueeze(0).unsqueeze(0).to(safe1.device)], dim = 1))
     safe2_batch.append(torch.cat([safe2[-1].unsqueeze(0).unsqueeze(0), torch.tensor(score).unsqueeze(0).unsqueeze(0).to(safe2.device)], dim = 1))
     score_batch.append(score)
     # logger.finish(t, env.max_episode_steps, score=score, value=0)
 
+
+#-----------------------------ziyi----------------------------------------------- 
+# Convert collected data to tensors and save (use sub_dir)
+makedirs(sub_dir)  # Ensure sub_dir exists
+
+# Save observations
+torch.save(torch.tensor(np.array(all_observations)), join(sub_dir, 'observations.pt'))
+
+# Save observations_env
+torch.save(torch.tensor(np.array(all_observations_env)), join(sub_dir, 'observations_env.pt'))
+
+# Save targets
+#torch.save(torch.tensor(np.array(all_targets)), join(sub_dir, 'targets.pt'))
+
+# Save diffusion_sm
+#torch.save(torch.tensor(np.array(all_diffusion_sm)), join(sub_dir, 'diffusion_sm_all.pt'))
+
+# Save safe1_batch
+torch.save(torch.cat(safe1_batch, dim=0), join(sub_dir, 'safe1_all.pt'))
+
+# Save safe2_batch
+torch.save(torch.cat(safe2_batch, dim=0), join(sub_dir, 'safe2_all.pt'))
+
+# Save scores
+torch.save(torch.tensor(score_batch), join(sub_dir, 'scores.pt'))
+
+# Save actions
+torch.save(torch.tensor(np.array(all_actions)), join(sub_dir, 'actions.pt'))
+
+# Save actions_adjusted
+torch.save(torch.tensor(np.array(all_actions_env)), join(sub_dir, 'actions_env.pt'))
+
+# New: Save next_observations
+#torch.save(torch.tensor(np.array(all_next_observations)), join(sub_dir, 'next_observations.pt'))
+#--------------------ziyi--------------------------------------------------------------------
+
 elbo_batch = np.array(elbo_batch)
 print("elbo mean: ", np.mean(elbo_batch))
 print("elbo std: ", np.std(elbo_batch))
@@ -205,6 +367,48 @@ score_batch = np.array(score_batch)
 safe1_batch = torch.cat(safe1_batch, dim=0)
 safe2_batch = torch.cat(safe2_batch, dim=0)
 comp_time = np.array(comp_time)
+
+#---------------Ziyi---------------------------
+# ... (你的所有代码，包括打印 elbo, score, etc. 的部分)
+
+# -------------------- ziyi: 保存统计数据到 YAML --------------------
+import yaml
+
+# 组织需要保存的数据
+results = {
+    "elbo_mean": float(np.mean(elbo_batch)),
+    "elbo_std": float(np.std(elbo_batch)),
+    "safe1_min": float(torch.min(safe1_batch[:, 0]).cpu().numpy()),
+    "safe2_min": float(torch.min(safe2_batch[:, 0]).cpu().numpy()),
+    "score_mean": float(np.mean(score_batch)),
+    "score_std": float(np.std(score_batch)),
+    "computation_time_mean": float(np.mean(comp_time)),
+    "success_rate": float(success)
+}
+
+# 组织需要保存的参数
+# 确保这些参数在你的 args 对象中存在
+
+
+# 合并所有数据
+data_to_save = {
+    "results": results,
+
+}
+
+# 构建 YAML 文件的完整路径
+yaml_path = join(sub_dir, 'summary.yaml')
+
+# 将数据保存为 YAML 文件
+try:
+    with open(yaml_path, 'w') as f:
+        yaml.dump(data_to_save, f, sort_keys=False) # sort_keys=False 保持字典的原始顺序
+    print(f"Summary saved to {yaml_path}")
+except Exception as e:
+    print(f"Error saving YAML file: {e}")
+
+# ... (代码的其他部分，如 exit() )
+#----------------Ziyi----------------------------
 print("safe1: ", torch.min(safe1_batch[:,0]).cpu().numpy())
 print("safe2: ", torch.min(safe2_batch[:,0]).cpu().numpy())
 print("score mean: ", np.mean(score_batch))
@@ -212,10 +416,13 @@ print("score std: ", np.std(score_batch))
 print("computation time: ", np.mean(comp_time))
 print("success rate: ", success)
 
-
+  #-----------------customize-------------------------------
+ 
+  #-----------------customize-------------------------------
 exit()
 
-import matplotlib.pyplot as plt
+#-----------------customize-------------------------------
+'''import matplotlib.pyplot as plt
 fig = plt.figure(figsize=(8, 4), facecolor='white')
 ax1 = fig.add_subplot(121, frameon=False)
 ax2 = fig.add_subplot(122, frameon=False)
@@ -239,15 +446,16 @@ plt.savefig(imgpath)
 
 import pdb; pdb.set_trace()
 
-exit()
-
+exit()'''
+#-----------------customize-------------------------------
 
 
 
 
 
 ## save result as a json file
-json_path = join(args.savepath, 'rollout.json')
+json_path = join(sub_dir, 'rollout.json')
 json_data = {'score': score, 'step': t, 'return': total_reward, 'term': terminal,
     'epoch_diffusion': diffusion_experiment.epoch}
 json.dump(json_data, open(json_path, 'w'), indent=2, sort_keys=True)
+
diff --git a/scripts/train.py b/scripts/train.py
index b1f384c..f9dd627 100644
--- a/scripts/train.py
+++ b/scripts/train.py
@@ -1,6 +1,7 @@
 import diffuser.utils as utils
 import pdb
-
+import matplotlib
+matplotlib.use('Agg')
 #export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/lib/nvidia-515
 #export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/wei/.mujoco/mujoco200/bin
 
@@ -120,9 +121,9 @@ print('✓')
 #--------------------------------- main loop ---------------------------------#
 #-----------------------------------------------------------------------------#
 
-n_epochs = int(args.n_train_steps // args.n_steps_per_epoch)
+n_epochs = int(args.n_train_steps // args.n_steps_per_epoch)  #n_train_steps: 2e6, n_steps_per_epoch:10000 n_epochs:200
 
 for i in range(n_epochs):
-    print(f'Epoch {i} / {n_epochs} | {args.savepath}')
+    print(f'Epoch {i} / {n_epochs} | {args.savepath}')  
     trainer.train(n_train_steps=args.n_steps_per_epoch)
 